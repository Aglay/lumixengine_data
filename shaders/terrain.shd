{
	"attributes" : ["in_position"],
	"shadowmap_required" : true
}

//BEGIN

#version 330

in vec3 in_position;

out vec4 position;
out vec2 tex_coords;
out vec2 global_uv;
out float cam_dist;

uniform float quad_size;
uniform float map_size;
uniform mat4 world_matrix;
uniform mat4 view_matrix;
uniform mat4 projection_matrix;
uniform sampler2D hm_texture;
uniform vec3 quad_min;
uniform vec3 camera_pos;
uniform vec3 morph_const;
uniform vec3 terrain_scale;

void main( void )
{
	float m = quad_size / 8;
	position = vec4(in_position, 1);  
	position.x *= quad_size;
	position.z *= quad_size;
	
	float fraction_x = fract(position.x / m) * m;
	float fraction_z = fract(position.z / m) * m;

	vec3 cp = camera_pos;
	cp.y = 0;
	vec4 pp = position;
	pp.y = 0;
	
	float dist = distance(cp, quad_min + pp.xyz);
	float weight = (dist - morph_const.y) / (morph_const.x - morph_const.y);
	weight =  clamp(weight, 0, 1);

	position.x = position.x - weight * fraction_x;
	position.z = position.z - weight * fraction_z;
	position += vec4(quad_min, 0);

	vec2 uv = position.xz / (map_size);
	uv.x += 0.5/map_size;
	uv.y += 0.5/map_size;
	position.y = terrain_scale.y * texture2D(hm_texture, uv).x;
	position.x *= terrain_scale.x;
	position.z *= terrain_scale.z;

	gl_Position = projection_matrix * view_matrix * world_matrix * position; 
	global_uv = uv;
	tex_coords = uv * m * map_size;
	gl_FrontColor = vec4(1.0, 1.0, 1.0, 1.0);
	cam_dist = dist;
}

//~VS
#version 330

in vec4				position;
in float 			cam_dist;
in vec2 			tex_coords;
in vec2 			global_uv;

uniform sampler2D	t1;
uniform sampler2D	t2;
uniform sampler2D	t3;
uniform sampler2D	t4;
uniform sampler2D	splat_texture;
uniform sampler2D	shadowmap;
uniform sampler2D hm_texture;
uniform sampler2D satellite_map;
uniform mat4 shadowmap_matrix0;
uniform mat4 shadowmap_matrix1;
uniform mat4 shadowmap_matrix2;
uniform mat4 shadowmap_matrix3;
uniform mat4 world_matrix;
uniform mat4 view_matrix;
uniform vec3 light_dir;
uniform float quad_size;
uniform vec3 brush_position;
uniform float brush_size;
uniform float detail_texture_distance;
uniform vec4 ambient_color;
uniform float ambient_intensity;
uniform vec4 diffuse_color;
uniform float diffuse_intensity;
uniform vec4 fog_color;
uniform float fog_density;

vec2 poissonDisk[4] = vec2[](
  vec2( -0.94201624, -0.39906216 ),
  vec2( 0.94558609, -0.76890725 ),
  vec2( -0.094184101, -0.92938870 ),
  vec2( 0.34495938, 0.29387760 )
);

float getFogFactor(float fFogCoord) 
{ 
	float fResult = exp(-pow(fog_density * fFogCoord, 2.0)); 
	fResult = 1.0-clamp(fResult, 0.0, 1.0); 
	return fResult;
}

void main( void )
{
	vec4 p = world_matrix * position;

	// calc normal
	vec2 tex_coord = global_uv;
	vec4 wave = texture2D(hm_texture, tex_coord);
	const vec2 size = vec2(0.005,0.0);
	const ivec3 off = ivec3(-1,0,1);
    float s11 = wave.x;
    float s01 = textureOffset(hm_texture, tex_coord, off.xy).x;
    float s21 = textureOffset(hm_texture, tex_coord, off.zy).x;
    float s10 = textureOffset(hm_texture, tex_coord, off.yx).x;
    float s12 = textureOffset(hm_texture, tex_coord, off.yz).x;
    vec3 va = normalize(vec3(size.xy, s21 - s01));
    vec3 vb = normalize(vec3(size.yx, s12 - s10));
	vec4 normal = vec4( cross(va, vb).xzy, s11 );
	
	// shadow
	vec3 shadow_coord[4] = vec3[](
		vec3(shadowmap_matrix0 * p),
		vec3(shadowmap_matrix1 * p),
		vec3(shadowmap_matrix2 * p),
		vec3(shadowmap_matrix3 * p)
	);
	vec2 tt[4] = vec2[](
		vec2(shadow_coord[0].x, shadow_coord[0].y * 0.25),
		vec2(shadow_coord[1].x, 0.25 + shadow_coord[1].y * 0.25),
		vec2(shadow_coord[2].x, 0.50 + shadow_coord[2].y * 0.25),
		vec2(shadow_coord[3].x, 0.75 + shadow_coord[3].y * 0.25)
	);
	
	int split_index = 0;
	if(shadow_coord[3].x < 0.99 && shadow_coord[3].x > 0.01
		&& shadow_coord[3].y < 0.99 && shadow_coord[3].y > 0.01)
		split_index = 3;
	if(shadow_coord[2].x < 0.99 && shadow_coord[2].x > 0.01
		&& shadow_coord[2].y < 0.99 && shadow_coord[2].y > 0.01)
		split_index = 2;
	if(shadow_coord[1].x < 0.99 && shadow_coord[1].x > 0.01
		&& shadow_coord[1].y < 0.99 && shadow_coord[1].y > 0.01)
		split_index = 1;
	if(shadow_coord[0].x < 0.99 && shadow_coord[0].x > 0.01
		&& shadow_coord[0].y < 0.99 && shadow_coord[0].y > 0.01)
		split_index = 0;

	float shadow = 1.0;
	if(shadow_coord[split_index].z <= 1	&& texture2D(shadowmap, tt[split_index]).z < shadow_coord[split_index].z)
		shadow = 0;
	//shadow = max(0.2, shadow * max(0.2, dot(normal.xyz, light_dir)));
	
	// surface
	vec4 splat = texture2D(splat_texture, global_uv).rgba;
	//splat = normalize(splat);
	vec4 surface = 
		texture2D(t1, tex_coords).rgba * splat.x
		+ texture2D(t2, tex_coords).rgba * splat.y
		+ texture2D(t3, tex_coords).rgba * splat.z
		+ texture2D(t4, tex_coords).rgba * splat.w;
	vec4 surface2 = texture2D(satellite_map, global_uv).rgba;
	float t = (cam_dist - detail_texture_distance) / detail_texture_distance;
	t = clamp(t, 0, 1);
	vec4 brush_color = vec4(0, 0, 1, 1) * (abs(distance(vec4(brush_position, 1), world_matrix * position) - brush_size) < 0.1 ? 1 : 0);
	surface = (surface * (1 - t) + surface2 * t) + brush_color;

	// result
	vec4 ambient = 			ambient_intensity * surface * ambient_color;
	vec4 diffuse = shadow * diffuse_intensity * surface * diffuse_color;

	p = view_matrix * p;
	gl_FragColor = mix(diffuse + ambient, fog_color, getFogFactor(p.z / p.w));
}
