{
	"attributes" : ["tc2"],
	"shadowmap_required" : true
}

//BEGIN

#version 120
varying vec3 normals;
varying vec4 position;
uniform float quad_size;
uniform float map_size;
uniform mat4 world_matrix;
uniform sampler2D hm_texture;
uniform vec3 quad_min;
uniform vec3 camera_pos;
uniform vec3 morph_const;

void main( void )
{
	normals = normalize(mat3(world_matrix) * gl_Normal);
	
	float w = 0;
	vec3 cp = camera_pos;
	cp.y = 0;
	vec4 pp = gl_Vertex * quad_size;
	pp.y = 0;
	//w = (distance(cp, quad_min + pp.xyz)) / (quad_size / 2);
	
	float dist = distance(cp, quad_min + pp.xyz);
	w = (dist - morph_const.x * 1.4142) * morph_const.y / 2;
	
	w = clamp(w, 0, 1);
	//w = 0.0;
	position = gl_Vertex;  
	position.x *= quad_size;
	position.z *= quad_size;
	
	float m = quad_size / 8;
	float frx = fract(position.x / m) * m;
	float frz = fract(position.z / m) * m;
	position.x = position.x - w * frx;
	position.z = position.z - w * frz;
	
	//position.x = position.x - frx * w;
	//position.z = (position.z / 2 - w * fract(gl_Vertex.z * quad_size / 2)) * 2;
	position += vec4(quad_min, 0);

	vec2 uv = position.xz / map_size;
	position.y = 60 * texture2D(hm_texture, uv).z;

	gl_Position = gl_ModelViewProjectionMatrix * position; 
	gl_TexCoord[0] = vec4(uv, 0, 0);

	 
	
	gl_FrontColor = vec4(0, w, 0, 1.0);
}

//~VS
#version 120
varying vec4		position;
varying vec3		normals;
uniform sampler2D	t1;
uniform sampler2D	t2;
uniform sampler2D	t3;
uniform sampler2D	t4;
uniform sampler2D	splat_texture;
uniform sampler2D	shadowmap;
uniform mat4 shadowmap_matrix0;
uniform mat4 shadowmap_matrix1;
uniform mat4 shadowmap_matrix2;
uniform mat4 shadowmap_matrix3;
uniform mat4 world_matrix;
uniform vec3 light_dir;
uniform float quad_size;

vec2 poissonDisk[4] = vec2[](
  vec2( -0.94201624, -0.39906216 ),
  vec2( 0.94558609, -0.76890725 ),
  vec2( -0.094184101, -0.92938870 ),
  vec2( 0.34495938, 0.29387760 )
);

void main( void )
{
	float visibility = 1.0;
	vec3 shadow_coord[4] = vec3[](
		vec3(shadowmap_matrix0 * world_matrix * position),
		vec3(shadowmap_matrix1 * world_matrix * position),
		vec3(shadowmap_matrix2 * world_matrix * position),
		vec3(shadowmap_matrix3 * world_matrix * position)
	);
	vec2 tt[4] = vec2[](
		vec2(shadow_coord[0].x, shadow_coord[0].y * 0.25),
		vec2(shadow_coord[1].x, 0.25 + shadow_coord[1].y * 0.25),
		vec2(shadow_coord[2].x, 0.50 + shadow_coord[2].y * 0.25),
		vec2(shadow_coord[3].x, 0.75 + shadow_coord[3].y * 0.25)
	);
	float near = 0.1;
	float far = 1000.0;
	float depth = gl_FragCoord.z;
	float linear_depth = (far - near) * (2.0 * near) / (far + near - depth * (far - near));
	int split_index = 0;
	if(shadow_coord[3].x < 0.99 && shadow_coord[3].x > 0.01
		&& shadow_coord[3].y < 0.99 && shadow_coord[3].y > 0.01)
		split_index = 3;
	if(shadow_coord[2].x < 0.99 && shadow_coord[2].x > 0.01
		&& shadow_coord[2].y < 0.99 && shadow_coord[2].y > 0.01)
		split_index = 2;
	if(shadow_coord[1].x < 0.99 && shadow_coord[1].x > 0.01
		&& shadow_coord[1].y < 0.99 && shadow_coord[1].y > 0.01)
		split_index = 1;
	if(shadow_coord[0].x < 0.99 && shadow_coord[0].x > 0.01
		&& shadow_coord[0].y < 0.99 && shadow_coord[0].y > 0.01)
		split_index = 0;
	
	//if(texture2D(shadowmap, tt[split_index]).z < shadow_coord[split_index].z)
//		visibility -= 0.5;
	//visibility = max(0.2, visibility * max(0.2, dot(normals, -light_dir)));
	vec4 splat = texture2D(splat_texture, gl_TexCoord[0].st).rgba;
	//splat = normalize(splat);
	vec4 texel = 
		texture2D(t1, gl_TexCoord[1].st).rgba * splat.x
		+ texture2D(t2, gl_TexCoord[1].st).rgba * splat.y
		+ texture2D(t3, gl_TexCoord[1].st).rgba * splat.z
		+ texture2D(t4, gl_TexCoord[1].st).rgba * splat.w;
//	if(texel.a < 0.30)
		//discard;
	gl_FragColor = texel * visibility;
	//gl_FragColor = vec4(normals, 1);
	//gl_FragColor = vec4(light_dir, 1);
	//gl_FragColor = vec4(1, 0, 0, 1);
	//gl_FragColor = gl_Color;
}
