{
	"passes" : ["MAIN", "SHADOW"],
	"shadowmap_required" : true,
	"attributes" : ["in_position", "in_normal", "in_tex_coords"]
}

//BEGIN

#version 330
#ifdef VERTEX_SHADER

in vec3 in_position;
in vec2 in_tex_coords;
in vec3 in_normal;

out vec3 normals;
out vec4 position;
out vec2 tex_coords;

uniform mat4 world_matrix;
uniform float time;
uniform mat4 view_matrix;
uniform mat4 projection_matrix;

void main( void )
{
	vec4 wind = vec4(1, 0, 0, 0);
	tex_coords = in_tex_coords;
	normals = normalize(mat3(world_matrix) * in_position);
	normals.y = 0.0;
	normals = normalize(normals);
	position = vec4(in_position, 1);
	position = position + position.y * 0.01 * sin(3*time+world_matrix[3].x*0.3) * wind;
	position = world_matrix * position;
	gl_Position = projection_matrix * view_matrix * position; 
	
	gl_FrontColor = vec4(1.0, 1.0, 1.0, 1.0);
}

#endif

#ifdef FRAGMENT_SHADER

	#ifdef SHADOW_PASS

		in vec2 			tex_coords;
		out vec4			out_color;
		uniform sampler2D	tDiffuse;

		void main( void )
		{
			#ifdef ALPHA_CUTOUT
				vec4 surface = texture2D(tDiffuse, tex_coords).rgba;
				if(surface.a < 0.3)
					discard;
				out_color = vec4(1, 1, 1, 1);
			#else
				out_color = vec4(tex_coords, 1, 1); // if I remove tex_coords from here, it also does not work correctly in #ifdef ALPHA_CUTOUT
			#endif
		}

	#else

		in vec4		position;
		in vec3		normals;
		in vec2 	tex_coords;

		out vec4			out_color;

		uniform sampler2D	tDiffuse;
		uniform sampler2D	shadowmap;
		uniform mat4 shadowmap_matrix0;
		uniform mat4 shadowmap_matrix1;
		uniform mat4 shadowmap_matrix2;
		uniform mat4 shadowmap_matrix3;
		uniform mat4 world_matrix;
		uniform mat4 view_matrix;
		uniform vec3 light_dir;
		uniform vec4 ambient_color;
		uniform float ambient_intensity;
		uniform vec4 diffuse_color;
		uniform float diffuse_intensity;
		uniform vec4 fog_color;
		uniform float fog_density;

		float getFogFactor(float fFogCoord) 
		{ 
			float fResult = exp(-pow(fog_density * fFogCoord, 2.0)); 
			fResult = 1.0-clamp(fResult, 0.0, 1.0); 
			return fResult;
		}


		float texture2DCompare(sampler2D depths, vec2 uv, ivec2 offset, float compare){
			float depth = textureOffset(depths, uv, offset).r;
			return step(compare, depth);
		}

		float PCF(sampler2D depths, vec2 size, vec2 uv, float compare){
			float result = 0.0;
			for(int x=-1; x<=1; x++){
				for(int y=-1; y<=1; y++){
					ivec2 off = ivec2(x,y);
					result += texture2DCompare(depths, uv, off, compare);
				}
			}
			return result/9.0;
		}

		float texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare){
			vec2 texelSize = vec2(1.0)/size;
			vec2 f = fract(uv*size+0.5);
			vec2 centroidUV = floor(uv*size+0.5)/size;

			float lb = texture2DCompare(depths, centroidUV, ivec2(0, 0), compare);
			float lt = texture2DCompare(depths, centroidUV, ivec2(0, 1), compare);
			float rb = texture2DCompare(depths, centroidUV, ivec2(1, 0), compare);
			float rt = texture2DCompare(depths, centroidUV, ivec2(1, 1), compare);
			float a = mix(lb, lt, f.y);
			float b = mix(rb, rt, f.y);
			float c = mix(a, b, f.x);
			return c;
		}


		void main( void )
		{
			#ifdef SHADOW_RECEIVER
				vec3 shadow_coord[4] = vec3[](
					vec3(shadowmap_matrix0 * position),
					vec3(shadowmap_matrix1 * position),
					vec3(shadowmap_matrix2 * position),
					vec3(shadowmap_matrix3 * position)
				);
				vec2 tt[4] = vec2[](
					vec2(shadow_coord[0].x * 0.5, shadow_coord[0].y * 0.5),
					vec2(0.5 + shadow_coord[1].x * 0.5, shadow_coord[1].y * 0.5),
					vec2(shadow_coord[2].x * 0.5, 0.50 + shadow_coord[2].y * 0.5),
					vec2(0.5 + shadow_coord[3].x * 0.5, 0.5 + shadow_coord[3].y * 0.5)
				);
				
				int split_index = 3;
				if(step(shadow_coord[0].x, 0.99) * step(shadow_coord[0].y, 0.99)
					* step(0.01, shadow_coord[0].x)	* step(0.01, shadow_coord[0].y) > 0)
					split_index = 0;
				else if(step(shadow_coord[1].x, 0.99) * step(shadow_coord[1].y, 0.99)
					* step(0.01, shadow_coord[1].x)	* step(0.01, shadow_coord[1].y) > 0)
					split_index = 1;
				else if(step(shadow_coord[2].x, 0.99) * step(shadow_coord[2].y, 0.99)
					* step(0.01, shadow_coord[2].x)	* step(0.01, shadow_coord[2].y) > 0)
					split_index = 2;
					
				float shadow = step(shadow_coord[split_index].z, 1) * texture2DShadowLerp(shadowmap, textureSize(shadowmap, 0), tt[split_index], shadow_coord[split_index].z - 0.0001);
				shadow = shadow * max(0, dot(normals, -light_dir));
			#endif

			vec4 surface = texture2D(tDiffuse, tex_coords).rgba;
			#ifdef ALPHA_CUTOUT
				if(surface.a < 0.30)
					discard;
			#endif

			vec4 ambient = 			ambient_intensity * surface * ambient_color;
			#ifdef SHADOW_RECEIVER
				vec4 diffuse = shadow * diffuse_intensity * surface * diffuse_color;
			#else
				vec4 diffuse = diffuse_intensity * surface * diffuse_color;
			#endif
				
			vec4 p = view_matrix * position;
			out_color = mix(ambient + diffuse, fog_color, getFogFactor(p.z / p.w));
			//out_color = vec4(normals.x, 0, 0, 1);
			//gl_FragColor = vec4(light_dir, 1);
			//gl_FragColor = vec4(1, 0, 0, 1);
		}

	#endif // if SHADOW_PASS else

#endif // FRAGMENT_SHADER