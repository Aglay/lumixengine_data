
{
	"passes" : ["MAIN", "SHADOW"],
	"attributes" : ["in_position", "in_tex_coords"],
	"shadowmap_required" : true
}

//BEGIN

#ifdef VERTEX_SHADER

in vec3 in_position;
in vec2 in_tex_coords;
in vec3 in_normal;
in vec3 in_tangents;

out vec3 normals;
out vec2 tex_coords;
out vec4 position;

uniform mat4 world_matrix[64];
uniform mat4 view_matrix;
uniform mat4 projection_matrix;

void main( void )
{
	tex_coords = in_tex_coords;
	normals = mat3(world_matrix[gl_InstanceID]) * vec3(in_normal.x / 127, in_normal.y / 127, in_normal.z / 127);
	
	position = world_matrix[gl_InstanceID] * vec4(in_position, 1);
	gl_Position = projection_matrix * (view_matrix * position); 

}

#endif // VERTEX_SHADER

#ifdef FRAGMENT_SHADER


	in vec2 			tex_coords;
	out vec4			out_color;
	uniform sampler2D	shadowmap;
	uniform sampler2D	tDiffuse;
	uniform sampler2D	tNormal;
	uniform sampler2D	tPosition;
	uniform mat4 shadowmap_matrix0;
	uniform mat4 shadowmap_matrix1;
	uniform mat4 shadowmap_matrix2;
	uniform mat4 shadowmap_matrix3;
	uniform vec4 ambient_color;
	uniform float ambient_intensity;
	uniform vec4 diffuse_color;
	uniform float diffuse_intensity;

	float texture2DCompare(sampler2D depths, vec2 uv, ivec2 offset, float compare){
		float depth = textureOffset(depths, uv, offset).r;
		return step(compare, depth);
	}

	float PCF(sampler2D depths, vec2 size, vec2 uv, float compare){
		float result = 0.0;
		for(int x=-1; x<=1; x++){
			for(int y=-1; y<=1; y++){
				ivec2 off = ivec2(x,y);
				result += texture2DCompare(depths, uv, off, compare);
			}
		}
		return result/9.0;
	}

	float texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare){
		vec2 texelSize = vec2(1.0)/size;
		vec2 f = fract(uv*size+0.5);
		vec2 centroidUV = floor(uv*size+0.5)/size;

		float lb = texture2DCompare(depths, centroidUV, ivec2(0, 0), compare);
		float lt = texture2DCompare(depths, centroidUV, ivec2(0, 1), compare);
		float rb = texture2DCompare(depths, centroidUV, ivec2(1, 0), compare);
		float rt = texture2DCompare(depths, centroidUV, ivec2(1, 1), compare);
		float a = mix(lb, lt, f.y);
		float b = mix(rb, rt, f.y);
		float c = mix(a, b, f.x);
		return c;
	}
	
	float computeShadow()
	{
		//vec4 normal = texture2D(tNormal, tex_coords).rgba;
		vec4 p = texture2D(tPosition, tex_coords).rgba;
		
		// shadow
		vec3 shadow_coord[4] = vec3[](
			vec3(shadowmap_matrix0 * p),
			vec3(shadowmap_matrix1 * p),
			vec3(shadowmap_matrix2 * p),
			vec3(shadowmap_matrix3 * p)
		);
		vec2 tt[4] = vec2[](
			vec2(shadow_coord[0].x * 0.5, shadow_coord[0].y * 0.5),
			vec2(0.5 + shadow_coord[1].x * 0.5, shadow_coord[1].y * 0.5),
			vec2(shadow_coord[2].x * 0.5, 0.50 + shadow_coord[2].y * 0.5),
			vec2(0.5 + shadow_coord[3].x * 0.5, 0.5 + shadow_coord[3].y * 0.5)
		);
		
		int split_index = 3;
		if(step(shadow_coord[0].x, 0.99) * step(shadow_coord[0].y, 0.99)
			* step(0.01, shadow_coord[0].x)	* step(0.01, shadow_coord[0].y) > 0)
			split_index = 0;
		else if(step(shadow_coord[1].x, 0.99) * step(shadow_coord[1].y, 0.99)
			* step(0.01, shadow_coord[1].x)	* step(0.01, shadow_coord[1].y) > 0)
			split_index = 1;
		else if(step(shadow_coord[2].x, 0.99) * step(shadow_coord[2].y, 0.99)
			* step(0.01, shadow_coord[2].x)	* step(0.01, shadow_coord[2].y) > 0)
			split_index = 2;

		return step(shadow_coord[split_index].z, 1) * texture2DShadowLerp(shadowmap, textureSize(shadowmap, 0), tt[split_index], shadow_coord[split_index].z - 0.0001);
	}
	
	void main( void )
	{
//		vec4 surface = texture2D(tNormal, tex_coords).rgba;
//		vec4 surface = texture2D(shadowmap, tex_coords).rgba;
		vec4 surface = texture2D(tDiffuse, tex_coords).rgba;
//		vec4 surface = texture2D(tPosition, tex_coords).rgba;
		vec4 ambient = ambient_intensity * surface * ambient_color;
		vec4 diffuse = computeShadow() * diffuse_intensity * surface * diffuse_color;
		out_color = ambient + diffuse;
		//out_color = texture2D(tNormal, tex_coords).rgba;
	}

#endif // FRAGMENT_SHADER