{
	"passes" : ["MAIN", "POINT_LIGHT"],
	"attributes" : ["in_position", "in_normal", "in_tangents", "in_tex_coords", "in_indices"],
	"shadowmap_required" : true
}

//BEGIN

#ifdef VERTEX_SHADER

in vec3 in_position;
in vec2 in_tex_coords;
in vec3 in_normal;
in float in_indices;

out vec3 normals;
out vec4 position;
out vec2 tex_coords;

uniform mat4 grass_matrices[64];
uniform mat4 view_matrix;
uniform mat4 projection_matrix;
uniform float time;
uniform vec3 camera_pos;
uniform float max_grass_distance = 10;

void main( void )
{
	
	vec4 wind = vec4(1, 0, 0, 0);
	mat4 grass_mtx = grass_matrices[int(in_indices)];
	tex_coords	= in_tex_coords / 2048;
	normals = normalize(mat3(grass_mtx) * in_normal);
	
	float scale = clamp(1.0 - (length(camera_pos - grass_mtx[3].xyz) - max_grass_distance) / max_grass_distance, 0.0, 1.0);
	position = vec4(in_position * scale, 1) + in_position.y * scale * 0.05 * sin(3*time+grass_mtx[3].x*0.3) * wind;
	
	position = grass_mtx * position;
	gl_Position = projection_matrix * view_matrix * position;
}

#endif


#ifdef FRAGMENT_SHADER

	#if __VERSION__ < 330
		#undef SHADOW_RECEIVER
	#endif

	in vec4 position;
	in vec2 tex_coords;

	out vec4			out_color;

	uniform sampler2D	tDiffuse;
	uniform vec3 light_dir;
	uniform mat4 shadowmap_matrix0;
	uniform mat4 shadowmap_matrix1;
	uniform mat4 shadowmap_matrix2;
	uniform mat4 shadowmap_matrix3;
	uniform sampler2D	shadowmap;
	uniform mat4 grass_matrices[64];
	uniform vec4 ambient_color;
	uniform float ambient_intensity;
	uniform vec4 diffuse_color;
	uniform float diffuse_intensity;
	uniform mat4 view_matrix;
	#ifdef POINT_LIGHT_PASS
		uniform vec3 light_pos;
		uniform float light_range;
	#endif

	#ifdef SHADOW_RECEIVER

	float texture2DCompare(sampler2D depths, vec2 uv, ivec2 offset, float compare){
		float depth = textureOffset(depths, uv, offset).r;
		return step(compare, depth);
	}

	float PCF(sampler2D depths, vec2 size, vec2 uv, float compare){
		float result = 0.0;
		for(int x=-1; x<=1; x++){
			for(int y=-1; y<=1; y++){
				ivec2 off = ivec2(x,y);
				result += texture2DCompare(depths, uv, off, compare);
			}
		}
		return result/9.0;
	}

	float texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare){
		vec2 texelSize = vec2(1.0)/size;
		vec2 f = fract(uv*size+0.5);
		vec2 centroidUV = floor(uv*size+0.5)/size;

		float lb = texture2DCompare(depths, centroidUV, ivec2(0, 0), compare);
		float lt = texture2DCompare(depths, centroidUV, ivec2(0, 1), compare);
		float rb = texture2DCompare(depths, centroidUV, ivec2(1, 0), compare);
		float rt = texture2DCompare(depths, centroidUV, ivec2(1, 1), compare);
		float a = mix(lb, lt, f.y);
		float b = mix(rb, rt, f.y);
		float c = mix(a, b, f.x);
		return c;
	}

	#endif

	#ifdef POINT_LIGHT_PASS
	
	void main( void )
	{
		float shadow = 1.0 - clamp((length(position.xyz - light_pos) / light_range), 0.0, 1.0);
		vec4 surface = texture2D(tDiffuse, tex_coords).rgba;
		#ifdef ALPHA_CUTOUT
			if(surface.a < 0.2)
				discard;
		#endif

		vec4 diffuse = shadow * diffuse_intensity * surface * diffuse_color;
			
		vec4 p = view_matrix * position;
		out_color = diffuse;
	}
	
	#else
	
	void main( void )
	{
		#ifdef SHADOW_RECEIVER
			vec4 shadow_coord[4] = vec4[](
				shadowmap_matrix0 * position,
				shadowmap_matrix1 * position,
				shadowmap_matrix2 * position,
				shadowmap_matrix3 * position
			);
			vec2 tt[4] = vec2[](
				vec2(shadow_coord[0].x * 0.5, shadow_coord[0].y * 0.5),
				vec2(0.5 + shadow_coord[1].x * 0.5, shadow_coord[1].y * 0.5),
				vec2(shadow_coord[2].x * 0.5, 0.50 + shadow_coord[2].y * 0.5),
				vec2(0.5 + shadow_coord[3].x * 0.5, 0.5 + shadow_coord[3].y * 0.5)
			);
			
			int split_index = 3;
			if(step(shadow_coord[0].x, 0.99) * step(shadow_coord[0].y, 0.99)
				* step(0.01, shadow_coord[0].x)	* step(0.01, shadow_coord[0].y) > 0)
				split_index = 0;
			else if(step(shadow_coord[1].x, 0.99) * step(shadow_coord[1].y, 0.99)
				* step(0.01, shadow_coord[1].x)	* step(0.01, shadow_coord[1].y) > 0)
				split_index = 1;
			else if(step(shadow_coord[2].x, 0.99) * step(shadow_coord[2].y, 0.99)
				* step(0.01, shadow_coord[2].x)	* step(0.01, shadow_coord[2].y) > 0)
				split_index = 2;

			float shadow = step(shadow_coord[split_index].z, 1) * texture2DShadowLerp(shadowmap, textureSize(shadowmap, 0), tt[split_index], shadow_coord[split_index].z);
		#endif
			
		vec4 surface = texture2D(tDiffuse, tex_coords).rgba;
		#ifdef ALPHA_CUTOUT
			if(surface.a < 0.2)
				discard;
		#endif

		vec4 ambient = 			ambient_intensity * surface * ambient_color;
		#ifdef SHADOW_RECEIVER
			vec4 diffuse = shadow * diffuse_intensity * surface * diffuse_color;
		#else
			vec4 diffuse = diffuse_intensity * surface * diffuse_color;
		#endif
			
		out_color = ambient + diffuse; 
	}
	#endif // if POINT_LIGHT_PASS else
	
#endif